//Progetto definitivo Vona Panetta
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FILENAME "Magazzino2.txt"
#define MAX_LEN 100

// Struttura base per ogni ricambio
typedef struct Ricambio {
    char nome[MAX_LEN];
    char codice[MAX_LEN];
    int quantita;
    char scaffalatura[MAX_LEN];
    int prezzo;
} Ricambio;

// Struttura del nodo per la lista concatenata
typedef struct Nodo {
    Ricambio ricambio;
    struct Nodo *next;     //puntatore al nodo successivo della lista
} Nodo;

// Prototipi delle funzioni
void menu();
void ricercaRicambio();
void aggiungiQuantita();
void decurtaQuantita();
void stampaRicambiOrdinati();
void stampaRicambiAlfabetici();
void visualizzaPrezzo();
void salvaRicambi(Ricambio *ricambi, int count);
int contaRigheFile(const char *filename);
int caricaRicambi(Ricambio **ricambi);
void ordinaRicambi(Ricambio *ricambi, int count);
void alertQuantita(int q);
Nodo* inserisciInOrdine(Nodo* head, Ricambio r);




int main() {
    menu();  // Avvia il menu per gestire il magazzino
    return 0;
}

void menu() {
    int scelta = 0;
    while (scelta != 7) {
        printf("\n--- GESTIONALE MAGAZZINO AUTOFFICINA ---\n");
        printf("1. Ricerca ricambio\n");
        printf("2. Aggiungi quantita' ricambio\n");
        printf("3. Decurtare quantita' ricambio\n");
        printf("4. Visualizza tutti i ricambi ordinati per scaffalatura\n");
        printf("5. Visualizza tutti i ricambi in ordine alfabetico per nome\n");
        printf("6. Visualizza prezzo\n");
        printf("7. Esci\n");
        printf("Scelta: ");
        scanf("%d", &scelta);
        getchar();

        switch (scelta) {
            case 1:
                ricercaRicambio();
                break;
            case 2:
                aggiungiQuantita();
                break;
            case 3:
                decurtaQuantita();
                break;
            case 4:
                stampaRicambiOrdinati();
                break;
            case 5:
                stampaRicambiAlfabetici();
                break;
            case 6:
                visualizzaPrezzo();
                break;
            case 7:
                printf("Uscita dal programma.\n");
                break;
            default:
                printf("Scelta non valida.\n");
        }
    }
}

void visualizzaPrezzo(){
    Ricambio *ricambi = NULL;
    int count = caricaRicambi(&ricambi);
    char codice[MAX_LEN];
    int trovato = 0;
    if (count == 0) {
        printf("Nessun ricambio presente.\n");
        return;
    }
    printf("Inserisci codice ricambio da cercare: ");
    fgets(codice, MAX_LEN, stdin);
    codice[strcspn(codice, "\n")] = 0;
    for (int i = 0; i < count; i++) {
        if (strcmp(ricambi[i].codice, codice) == 0) {
            printf("\nRicambio trovato:\n");
            printf("  Prezzo : %d euro\n", ricambi[i].prezzo);
            trovato = 1;
            break;
        }
    }
    if (trovato==0) {
        printf("Ricambio NON trovato.\n");
    }

    free(ricambi);
}


//1
void ricercaRicambio() {
    Ricambio *ricambi = NULL;          //ricambi è un puntatore a una struttura di tipo Ricambio
    int count = caricaRicambi(&ricambi);
    char codice[MAX_LEN];                //codice = codice ricambio
    int trovato = 0;
//uso count (numero di righe del file) come mezzo di controllo in modo da verificare che il file non sia vuoto
    if (count == 0) {
        printf("Nessun ricambio presente.\n");
        return;
    }

    printf("Inserisci codice ricambio da cercare: ");
    fgets(codice, MAX_LEN, stdin);   //legge da stdin, copia fino a maxlen-1 caratteri, inserisce nell'array CODICE




    codice[strcspn(codice, "\n")] = 0; /*sostituisce \0 allo \n qualora dovesse essere presente in modo da evitare alcuni problemi*/




    for (int i = 0; i < count; i++) {
        if (strcmp(ricambi[i].codice, codice) == 0) {
            printf("\nRicambio trovato:\n");
            printf("  Nome: %s\n", ricambi[i].nome);
            printf("  Codice: %s\n", ricambi[i].codice);
            printf("  Quantita': %d\n", ricambi[i].quantita);
            printf("  Scaffalatura: %s\n", ricambi[i].scaffalatura);
            alertQuantita(ricambi[i].quantita);
            trovato = 1;
            break;      //viene utilizzato affinché una volta trovato il ricambio non continuo a cercare ed esco dal for
        }
    }

    if (trovato==0) {
        printf("Ricambio NON trovato.\n");
    }

    free(ricambi);
}

//2
int caricaRicambi(Ricambio **ricambi) {       //carica ricambi nella malloc
    int count = contaRigheFile(FILENAME);
    FILE *file = fopen(FILENAME, "r");

    if (count == 0 || file==NULL) return 0;

    *ricambi = malloc(count * sizeof(Ricambio));
    if (*ricambi == NULL) {
        printf("Errore allocazione memoria.\n");
        exit(1);
    }
//il ciclo for riempie un array dinamico precedentemente creato (malloc)
    for (int i = 0; i < count; i++) {
        fscanf(file, "%99[^;];%99[^;];%d;%99[^;];%d\n",  //99[^;] sta ad indicare che legge al massimo 99 caratteri tranne ;
               (*ricambi)[i].nome,
               (*ricambi)[i].codice,
               &(*ricambi)[i].quantita,     //uso & perché è un intero
               (*ricambi)[i].scaffalatura,
               &(*ricambi)[i].prezzo);  //aggiunta che ho fatto per la funzione prezzo
    }

    fclose(file);
    return count;
}

//3
int contaRigheFile(const char *filename) {
    FILE *file = fopen(filename, "r");
    int righe = 0;
    char ch;

    if (file==NULL)
        return 0;

    while ((ch = fgetc(file)) != EOF) {
        if (ch == '\n')
            righe++;
    }

    fclose(file);
    return righe;
}


void alertQuantita(int q) {
    if (q == 0) {
        printf("PARTICOLARE NON PRESENTE IN MAGAZZINO\n");
    }
    else if (q <= 4) {
        printf("ATTENZIONE: Quantita' in magazzino = %d\n", q);
    }
     else if (q > 4) {
        printf("Quantita' = %d\n", q);
    }
}



void aggiungiQuantita() {
    Ricambio *ricambi = NULL;          //ricambi è un puntatore a una struttura di tipo Ricambio
    int count = caricaRicambi(&ricambi);
    char codice[MAX_LEN];
    int quantita;

    if (count == 0) {
        printf("Nessun ricambio presente.\n");
        return;
    }

    printf("Inserisci codice ricambio: ");
    fgets(codice, MAX_LEN, stdin);




    codice[strcspn(codice, "\n")] = 0;   /*sostituisce \0 allo \n qualora dovesse essere presente in modo da evitare alcuni problemi*/






    printf("Inserisci quantita' da aggiungere: ");
    scanf("%d", &quantita);
    getchar();     //rimuove l'eventuale \n rimasto nel buffer

    int trovato = 0;
    for (int i = 0; i < count; i++) {
        if (strcmp(ricambi[i].codice, codice) == 0) {
            ricambi[i].quantita += quantita;          //ricambi[i].quantita = ricambi[i].quantita + quantita
            alertQuantita(ricambi[i].quantita);
            trovato = 1;
            break;
        }
    }

    if (trovato==0) {
        printf("Ricambio NON trovato.\n");
    } else {
        salvaRicambi(ricambi, count);
        printf("Quantita' aggiunta con successo.\n");
    }

    free(ricambi);
}

void decurtaQuantita() {
    Ricambio *ricambi = NULL;
    int count = caricaRicambi(&ricambi);
    char codice[MAX_LEN];
    int quantita;

    if (count == 0) {
        printf("Nessun ricambio presente.\n");
        return;
    }

    printf("Inserisci codice ricambio: ");
    fgets(codice, MAX_LEN, stdin);





    codice[strcspn(codice, "\n")] = 0;  /*sostituisce \0 allo \n qualora dovesse essere presente in modo da evitare alcuni problemi*/







    printf("Inserisci quantita' da decurtare: ");
    scanf("%d", &quantita);
    getchar();               //rimuove \n

    int trovato = 0;
    for (int i = 0; i < count; i++) {
        if (strcmp(ricambi[i].codice, codice) == 0) {
            if (ricambi[i].quantita >= quantita) {
                ricambi[i].quantita -= quantita;
                alertQuantita(ricambi[i].quantita);
                trovato = 1;
            }
            else {
                printf("Quantita' insufficiente. Operazione non eseguita.\n");
                free(ricambi);
                return;
            }
            break;
        }
    }

    if (trovato==0) {
        printf("Ricambio NON trovato.\n");
    } else {
        salvaRicambi(ricambi, count);
        printf("Quantita' decurtata con successo.\n");
    }

    free(ricambi);
}




//un problema di questa istruzione è che volta per volta viene ricopiato tutto il file di testo perciò non è molto efficiente
void salvaRicambi(Ricambio *ricambi, int count) {
    FILE *file = fopen(FILENAME, "w");

    for (int i = 0; i < count; i++) {
        fprintf(file, "%s;%s;%d;%s;%d\n",
                ricambi[i].nome,
                ricambi[i].codice,
                ricambi[i].quantita,
                ricambi[i].scaffalatura,
                ricambi[i].prezzo);    //aggiunta per la funzione prezzo
    }

    fclose(file);
}


void stampaRicambiOrdinati() {
    Ricambio *ricambi = NULL;
    int count = caricaRicambi(&ricambi);

    if (count == 0) {
        printf("Nessun ricambio da visualizzare.\n");
        return;
    }

    ordinaRicambi(ricambi, count);

    printf("\n--- RICAMBI ORDINATI PER SCAFFALATURA ---\n");
    for (int i = 0; i < count; i++) {
//%-20s lo uso per far si da avere una "inquadratura" dei ricambi e delle informazioni inserite. 20 indica che ho almeno 20 spazi per il nome
         printf("%-20s | Codice: %-10s | Quantità: %-3d | Scaffale: %s\n",
               ricambi[i].nome,
               ricambi[i].codice,
               ricambi[i].quantita,
               ricambi[i].scaffalatura);
    }

    free(ricambi);
}


//questa funzione fa uso del bubble sort per l'ordinamento
void ordinaRicambi(Ricambio *ricambi, int count) {
    Ricambio temp;     //temp è una variabile locale (della funzione) di tipo struct RICAMBIO
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - i - 1; j++) {
            if (strcmp(ricambi[j].scaffalatura, ricambi[j + 1].scaffalatura) > 0) {   /*se >0 l'elemento precedente viene scambiato*/
                temp = ricambi[j];
                ricambi[j] = ricambi[j + 1];
                ricambi[j + 1] = temp;
            }
        }
    }
}



void stampaRicambiAlfabetici() {
    Ricambio *ricambi = NULL;          //ricambi è un puntatore alla struct RICAMBIO
    int count = caricaRicambi(&ricambi);

    if (count == 0) {
        printf("Nessun ricambio da visualizzare.\n");
        return;
    }

    Nodo *head = NULL;       //head è un puntatore alla struct NODO

    for (int i = 0; i < count; i++) {
        head = inserisciInOrdine(head, ricambi[i]);
    }

    printf("\n--- RICAMBI ORDINATI ALFABETICAMENTE PER NOME ---\n");
    Nodo *curr = head;   /*puntatore curr di tipo nodo che punta alla testa. Uso curr per scorrere la lista senza modificare HEAD*/
    //scorro la lista curr e stampo tutti gli elementi N.B. while(curr) = while(curr!=NULL)
    while (curr!=NULL) {
        printf("%-20s | Codice: %-10s | Quantità: %-3d | Scaffale: %s\n",
               curr->ricambio.nome,      //accede al campo nome dentro la struttura ricambio
               curr->ricambio.codice,
               curr->ricambio.quantita,
               curr->ricambio.scaffalatura);
        curr = curr->next;
    }

    //dealloco la memoria riservata alla lista concatenata scorrendo tutta la lista a partire da HEAD
    while (head!=NULL) {
        Nodo *tmp = head;    //salvo in tmp l'attuale testa della lista concatenata
        head = head->next;    //head è il primo nodo della lista e vado al successivo finche non arrivo a puntare NULL
        free(tmp);  //libero volta per volta la memoria allocata per ogni singolo nodo
    }

    //libero la memoria allocata per l'array dinamico ricambi
    free(ricambi);
}




//scrivo la funzione di ordinamento che fa uso del bubble sort e restituisce il puntatore NODO alla testa della lista concatenata
Nodo* inserisciInOrdine(Nodo* head, Ricambio r) {
   //alloco un nuovo nodo
   Nodo *nuovo = malloc(sizeof(Nodo));
    if (nuovo==NULL) {
        printf("Errore allocazione memoria.\n");
        exit(1);
    }
    //NUOVO è un puntatore ad un nodo di tipo struct NODO
    //ricambio prende tutti i parametri di r e li copia dentro il nodo
    /*ricambio è un elemento presente nella struct nodo. Così faccio una copia diretta dell’intera struct r dentro il campo ricambio del nodo*/
    nuovo->ricambio = r;
    //inizializzo il nodo successivo a NULL in modo da evitare comportamenti indesiderati
    nuovo->next = NULL;
/*se la lista è vuota, NUOVO diventa il primo nodo della lista o se il nome del ricambio r precede quello di head, NUOVO è il primo nodo della lista e contiene HEAD (scambio i nodi)*/
    if (head==NULL || strcmp(r.nome, head->ricambio.nome) < 0) {
        nuovo->next = head;
        return nuovo;
    }

    Nodo *curr = head;    //creo il puntatore curr che punta alla testa della lista

    //verifico che ci sia un nodo successivo a quello attuale oppure se la lista è finita
    //se l'attuale ricambio è alfabeticamente successivo al next, vado al next successivo e riconfronto


    while (curr->next && strcmp(r.nome, curr->next->ricambio.nome) > 0) {
        curr = curr->next;
    }


    /*il ciclo while si ferma quando la comparazione fra il nome del ricambio attuale e quello del ricambio nel nodo successivo restituisce valore minore di 0, cioè quando il ricambio attuale viene alfabeticamente prima di quello nel nodo successivo. Così facendo ho trovato la posizione corretta del mio ricambio*/

    //una volta trovata la posizione corretta devo inserire il nuovo nodo contenente il ricambio fra il CURR ed il CURR NEXT
    //esempio prima:[A] -> [B] -> [C] dopo: [A] -> [B] -> [X] -> [C]
    nuovo->next = curr->next;    //X->next = C
    curr->next = nuovo;          //B->next = X
    return head;
}
